From 965bc4054f524c43f255bc7f1754fa7747a1eaee Mon Sep 17 00:00:00 2001
From: Aaron Ferrucci <aferrucc@altera.com>
Date: Mon, 14 Jul 2014 13:51:48 -0700
Subject: [PATCH] FogBugz #175246: Rename sld-hub to mm-debug-link; add new
 commands.

The name "sld-hub" happens to reflect current usage of this driver, but
in the future we may come up with other uses for the debug hardware.
In actuality, the driver code communicates with an instance of
altera_mm_debug_link (which in turn communicates with the SLD Hub
controller hardware). The first part of this change is a search-
and-replace from "sld-hub"-like text to "mm-debug-link"-like text.
-----------------------------------------------------------------
The second part of this change adds new functionality to this
driver, implemented via ioctl:
  - ENABLE command
  - RESET command
  - version
  - signature ("SysC")
-----------------------------------------------------------------
The ioctl command values are implemented via the standard _IOR
and _IOW macros defined in linux/ioctl.h, using a "type" value
of 0xA1 (reserved in Documentation/ioctl/ioctl-number.txt).
-----------------------------------------------------------------
During testing, I noted that the size of the hardware FIFOs within
altera_mm_debug_link have a significant effect on performance. I've
laid the groundwork for allowing the user ot choose the size of
those FIFOs by adding registers for reading out the FIFO sizes,
and having the driver allocate a buffer (pdata->kbuf) of the correct
size (as opposed to having a fixed-size buffer).
-----------------------------------------------------------------
These changes were originally covered in a previous review:
  crucible:8060/cru/linux-socfpga-693
But enough time has passed (and changes made that were not
part of the original concept) that I think it's worth starting
fresh with a new review.

V2: Add version check; minor cleanup.

Signed-off-by: Aaron Ferrucci <aferrucc@altera.com>
---
 .../bindings/arm/altera/mm-debug-link.txt          |  19 +
 .../devicetree/bindings/arm/altera/sld-hub.txt     |  19 -
 Documentation/ioctl/ioctl-number.txt               |   1 +
 drivers/char/Kconfig                               |  10 +-
 drivers/char/Makefile                              |   2 +-
 drivers/char/mm-debug-link.c                       | 442 +++++++++++++++++++++
 drivers/char/sld-hub.c                             | 305 --------------
 include/linux/mm-debug-link.h                      |  39 ++
 8 files changed, 508 insertions(+), 329 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/arm/altera/mm-debug-link.txt
 delete mode 100644 Documentation/devicetree/bindings/arm/altera/sld-hub.txt
 create mode 100644 drivers/char/mm-debug-link.c
 delete mode 100644 drivers/char/sld-hub.c
 create mode 100644 include/linux/mm-debug-link.h

diff --git a/Documentation/devicetree/bindings/arm/altera/mm-debug-link.txt b/Documentation/devicetree/bindings/arm/altera/mm-debug-link.txt
new file mode 100644
index 0000000..46999d1
--- /dev/null
+++ b/Documentation/devicetree/bindings/arm/altera/mm-debug-link.txt
@@ -0,0 +1,19 @@
+Altera MM Debug Link driver
+
+Required properties:
+
+- #address-cells, #size-cells : Both #address-cells
+  and #size-cells must be equal to 1.
+
+- compatible : "altr,mm-debug-link-1.0";
+
+- reg : Base address and size of register space in MM Debug Link.
+
+Example:
+
+        sldhub_link: debugger {
+                #address-cells = <1>;
+                #size-cells = <1>;
+                compatible = "altr,mm-debug-link-1.0";
+                reg = <0xFF240000 0x80>;
+        };
diff --git a/Documentation/devicetree/bindings/arm/altera/sld-hub.txt b/Documentation/devicetree/bindings/arm/altera/sld-hub.txt
deleted file mode 100644
index f7fafad..0000000
--- a/Documentation/devicetree/bindings/arm/altera/sld-hub.txt
+++ /dev/null
@@ -1,19 +0,0 @@
-Altera SLD HUB driver
-
-Required properties:
-
-- #address-cells, #size-cells : Both #address-cells
-  and #size-cells must be equal to 1.
-
-- compatible : "altr,sld-hub";
-
-- reg : Base address and size of register space in SLD HUB controller
-
-Example:
-
-	sldhub: debugger {
-		#address-cells = <1>;
-		#size-cells = <1>;
-		compatible = "altr,sld-hub";
-		reg = <0xFF240000 0x80>;
-	};
diff --git a/Documentation/ioctl/ioctl-number.txt b/Documentation/ioctl/ioctl-number.txt
index 7cbfa3c..6c59281 100644
--- a/Documentation/ioctl/ioctl-number.txt
+++ b/Documentation/ioctl/ioctl-number.txt
@@ -295,6 +295,7 @@ Code  Seq#(hex)	Include File		Comments
 					<mailto:buk@buks.ipn.de>
 0xA0	all	linux/sdp/sdp.h		Industrial Device Project
 					<mailto:kenji@bitgate.com>
+0xA1    00-1F   linux/mm-debug-link.h   <mailto:aferrucc@altera.com>
 0xA2	00-0F	arch/tile/include/asm/hardwall.h
 0xA3	80-8F	Port ACL		in development:
 					<mailto:tlewis@mindspring.com>
diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index c453c0a..8e8b294 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -599,12 +599,14 @@ config TILE_SROM
 	  device appear much like a simple EEPROM, and knows
 	  how to partition a single ROM for multiple purposes.
 
-config SLDHUB
-	tristate "SLD HUB driver"
-	depends on m
+config ALTERA_MMDEBUGLINK
+	tristate "Altera MM Debug Link Driver"
 	depends on OF
 	help
-		The System-Level Debug HUB supports debugging of Altera FPGA Designs
+          The MM Debug Link supports debugging of Altera FPGA Designs
+          which contain the altera_mm_debug_link hardware component. The
+          altera_mm_debug_link component provides access to debug logic
+          via an Avalon-MM slave interface.
 
 endmenu
 
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 7808c50..33db59f 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -63,4 +63,4 @@ js-rtc-y = rtc.o
 
 obj-$(CONFIG_TILE_SROM)		+= tile-srom.o
 
-obj-$(CONFIG_SLDHUB)	+= sld-hub.o
+obj-$(CONFIG_ALTERA_MMDEBUGLINK) += mm-debug-link.o
diff --git a/drivers/char/mm-debug-link.c b/drivers/char/mm-debug-link.c
new file mode 100644
index 0000000..d8c28eb
--- /dev/null
+++ b/drivers/char/mm-debug-link.c
@@ -0,0 +1,442 @@
+/*
+ *  drivers/char/mm-debug-link.c
+ *
+ * MM DEBUG_LINK driver
+ *
+ * Adapted from sld-hub driver written by Graham Moore (grmoore@altera.com)
+ *
+ * Copyright (C) 2014 Altera Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/cdev.h>
+#include <linux/debugfs.h>
+#include <linux/kfifo.h>
+#include <linux/mm-debug-link.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/uaccess.h>
+
+#define MM_DEBUG_LINK_NAME "mm_debug_link"
+
+#define MM_DEBUG_LINK_DATA_WRITE        0x00
+#define MM_DEBUG_LINK_WRITE_CAPACITY    0x04
+#define MM_DEBUG_LINK_DATA_READ         0x08
+#define MM_DEBUG_LINK_READ_CAPACITY     0x0C
+#define MM_DEBUG_LINK_FIFO_WRITE_COUNT  0x20
+#define MM_DEBUG_LINK_FIFO_READ_COUNT   0x40
+#define MM_DEBUG_LINK_ID_ROM            0x60
+#define MM_DEBUG_LINK_SIGNATURE         0x70
+#define MM_DEBUG_LINK_VERSION           0x74
+#define MM_DEBUG_LINK_DEBUG_RESET       0x78
+#define MM_DEBUG_LINK_MGMT_INTF         0x7C
+
+/*
+ * The value to expect at offset MM_DEBUG_LINK_SIGNATURE, aka "SysC".
+ */
+#define EXPECT_SIGNATURE 0x53797343
+
+/*
+ * The maximum version this driver supports.
+ */
+#define MAX_SUPPORTED_VERSION 1
+
+/*
+ * The size of mm_debug_link_pdata.read_kfifo. It must be a power of 2 to
+ *  satisfy kfifo_alloc(). Data is transferred from the read FIFO within
+ *  altera_mm_debug_link into this kfifo. The value was determined by
+ *  trial and error; it must be large enough to avoid overflow when
+ *  reading while writing.
+ */
+#define MM_DEBUG_LINK_READ_BUF_SIZE     4096
+
+#define MM_DEBUG_LINK_FLAG_BUSY         0
+
+struct mm_debug_link_pdata {
+	struct platform_device *pdev;
+
+	unsigned int base_reg_phy;
+	void __iomem *base_reg;
+
+	unsigned long flags;
+
+	struct kfifo read_kfifo;
+	unsigned char *kbuf;
+	size_t fifo_capacity;
+
+	struct cdev mmdebuglink_cdev;
+};
+
+static int mm_debug_link_remove(struct platform_device *pdev);
+
+static struct class *mm_debug_link_class;
+
+/*
+ * _read_mmdebuglink_into_kfifo()
+ *
+ * Private helper function.
+ *
+ * Read all available bytes from the mm debug link's read FIFO into
+ * pdata->read_kfifo.
+ *
+ * Return: the number of bytes written into pdata->read_kfifo.
+ */
+static int _read_mmdebuglink_into_kfifo(struct mm_debug_link_pdata *pdata)
+{
+	int num_bytes;
+	int n;
+	char chr;
+
+
+	num_bytes = readb(pdata->base_reg + MM_DEBUG_LINK_FIFO_READ_COUNT);
+	for (n = 0; n < num_bytes; n++) {
+		if (kfifo_is_full(&pdata->read_kfifo))
+			/*
+			 * The read FIFO is full.
+			 *
+			 */
+			break;
+		chr = readb(pdata->base_reg + MM_DEBUG_LINK_DATA_READ);
+		kfifo_in(&pdata->read_kfifo, &chr, 1);
+	}
+
+	return n;
+}
+
+/*
+ * mm_debug_link_write() - file_operations API write function
+ *
+ * Return: the number of bytes written.
+ */
+static ssize_t mm_debug_link_write(
+	struct file *file,
+	const char __user *user_buf,
+	size_t count,
+	loff_t *ppos)
+{
+	struct mm_debug_link_pdata *pdata = file->private_data;
+	int num_bytes;
+	int n;
+
+	/*
+	 * If the debug link's read FIFO fills, the write FIFO will eventually
+	 * fill, and then the hardware will stop accepting write data. Avoid
+	 * deadlock by servicing the read FIFO before writing.
+	 */
+	_read_mmdebuglink_into_kfifo(pdata);
+
+	/*
+	 * num_bytes is the number of unused byte locations in the write FIFO.
+	 */
+	num_bytes = pdata->fifo_capacity -
+		readb(pdata->base_reg + MM_DEBUG_LINK_FIFO_WRITE_COUNT);
+
+	if (num_bytes == 0)
+		/*
+		 * The write FIFO is full: don't accept data.
+		 */
+		return 0;
+
+	*ppos = 0;
+	num_bytes = simple_write_to_buffer(pdata->kbuf,
+				num_bytes, ppos, user_buf, count);
+
+	for (n = 0; n < num_bytes; n++)
+		writeb(pdata->kbuf[n],
+		       pdata->base_reg + MM_DEBUG_LINK_DATA_WRITE);
+
+	return num_bytes;
+}
+
+/*
+ * mm_debug_link_read() - file_operations API read function
+ *
+ * Return: the number of bytes read.
+ */
+static ssize_t mm_debug_link_read(struct file *file, char __user *user_buf,
+			    size_t count, loff_t *ppos)
+{
+	int num_bytes;
+	struct mm_debug_link_pdata *pdata = file->private_data;
+
+	_read_mmdebuglink_into_kfifo(pdata);
+
+	if (kfifo_to_user(&pdata->read_kfifo, user_buf, count, &num_bytes))
+		dev_err(&pdata->pdev->dev,
+			"Error copying fifo data to user data! %d bytes copied\n",
+			num_bytes);
+	return num_bytes;
+}
+
+/*
+ * mm_debug_link_open() - file_operations API open function
+ *
+ * Return: 0 on success, non-zero error code on error.
+ */
+static int mm_debug_link_open(struct inode *inode, struct file *file)
+{
+	struct mm_debug_link_pdata *pdata;
+
+	pdata = container_of(inode->i_cdev, struct mm_debug_link_pdata,
+		mmdebuglink_cdev);
+
+	if (test_and_set_bit_lock(MM_DEBUG_LINK_FLAG_BUSY, &pdata->flags))
+		return -EBUSY;
+	file->private_data = pdata;
+
+	return 0;
+}
+
+/*
+ * mm_debug_link_release() - file_operations API release function
+ *
+ * Return: 0 on success, error code on error.
+ */
+static int mm_debug_link_release(struct inode *inode, struct file *file)
+{
+	int ret = 0;
+	struct mm_debug_link_pdata *pdata;
+
+	pdata = container_of(inode->i_cdev, struct mm_debug_link_pdata,
+		mmdebuglink_cdev);
+	file->private_data = NULL;
+	clear_bit_unlock(MM_DEBUG_LINK_FLAG_BUSY, &pdata->flags);
+
+	return ret;
+}
+
+static long mm_debug_link_read_romid(struct mm_debug_link_pdata *pdata,
+	unsigned long arg)
+{
+	int i;
+
+	for (i = 0; i < MM_DEBUG_LINK_ID_SIZE; i++)
+		pdata->kbuf[i] = readb(pdata->base_reg +
+				MM_DEBUG_LINK_ID_ROM + i);
+
+	if (copy_to_user((void __user *)arg, pdata->kbuf,
+			 MM_DEBUG_LINK_ID_SIZE))
+		return -EFAULT;
+
+	return 0;
+}
+
+static long mm_debug_link_write_mixer(struct mm_debug_link_pdata *pdata,
+	unsigned long arg)
+{
+	writeb(arg, pdata->base_reg + MM_DEBUG_LINK_ID_ROM);
+	return 0;
+}
+
+static long mm_debug_link_enable(struct mm_debug_link_pdata *pdata,
+	unsigned long arg)
+{
+	writel(arg, pdata->base_reg + MM_DEBUG_LINK_MGMT_INTF);
+	return 0;
+}
+
+static long mm_debug_link_debug_reset(struct mm_debug_link_pdata *pdata,
+	unsigned long arg)
+{
+	writel(arg, pdata->base_reg + MM_DEBUG_LINK_DEBUG_RESET);
+	return 0;
+}
+
+static long mm_debug_link_ioctl(struct file *file, unsigned int cmd,
+	unsigned long arg)
+{
+	struct mm_debug_link_pdata *pdata = file->private_data;
+	long result = -ENOIOCTLCMD;
+
+	switch (cmd) {
+	case MM_DEBUG_LINK_IOCTL_READ_ID:
+		result = mm_debug_link_read_romid(pdata, arg);
+		break;
+	case MM_DEBUG_LINK_IOCTL_WRITE_MIXER:
+		result = mm_debug_link_write_mixer(pdata, arg);
+		break;
+	case MM_DEBUG_LINK_IOCTL_ENABLE:
+		result = mm_debug_link_enable(pdata, arg);
+		break;
+	case MM_DEBUG_LINK_IOCTL_DEBUG_RESET:
+		result = mm_debug_link_debug_reset(pdata, arg);
+		break;
+	}
+
+	return result;
+}
+
+static const struct file_operations mm_debug_link_fops = {
+	.write = mm_debug_link_write,
+	.read = mm_debug_link_read,
+	.open = mm_debug_link_open,
+	.release = mm_debug_link_release,
+	.unlocked_ioctl = mm_debug_link_ioctl,
+	.llseek = no_llseek,
+};
+
+/*
+ * mm_debug_link_probe() - platform device API probe function
+ *
+ * Return: 0 on success, non-zero error code on error.
+ */
+static int mm_debug_link_probe(struct platform_device *pdev)
+{
+	struct resource *areg;
+	struct mm_debug_link_pdata *pdata;
+	int ret;
+	unsigned long sig = 0L, version = 0L;
+	size_t kbuf_size;
+	dev_t dev;
+
+	pdata = devm_kzalloc(&pdev->dev, sizeof(struct mm_debug_link_pdata),
+			     GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	areg = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	pdata->base_reg = devm_request_and_ioremap(&pdev->dev, areg);
+	if (!pdata->base_reg)
+		return -EADDRNOTAVAIL;
+
+	/* Check the signature, fail if not found. */
+	sig = readl(pdata->base_reg + MM_DEBUG_LINK_SIGNATURE);
+	if (sig != EXPECT_SIGNATURE)
+		return -ENODEV;
+
+	/* Check the version, fail if not compatible */
+	version = readl(pdata->base_reg + MM_DEBUG_LINK_VERSION);
+	if (version > MAX_SUPPORTED_VERSION)
+		return -ENODEV;
+
+	pdata->fifo_capacity = readl(pdata->base_reg +
+				  MM_DEBUG_LINK_WRITE_CAPACITY);
+	/*
+	 * kbuf is used both for the link ID value, and for data on its way
+	 * into the write FIFO. Allocate a buffer large enough for either.
+	 */
+	kbuf_size = max(MM_DEBUG_LINK_ID_SIZE, pdata->fifo_capacity);
+	pdata->kbuf = devm_kzalloc(&pdev->dev, kbuf_size, GFP_KERNEL);
+
+	if (!pdata->kbuf)
+		return -ENOMEM;
+
+	pdata->base_reg_phy = areg->start;
+
+	pdata->pdev = pdev;
+	platform_set_drvdata(pdev, pdata);
+
+	if (kfifo_alloc(&pdata->read_kfifo,
+			MM_DEBUG_LINK_READ_BUF_SIZE, GFP_KERNEL))
+		return -ENOMEM;
+
+	mm_debug_link_class = class_create(THIS_MODULE, MM_DEBUG_LINK_NAME);
+	if (IS_ERR(mm_debug_link_class)) {
+		ret = PTR_ERR(mm_debug_link_class);
+		goto free_kfifo;
+	}
+
+	ret = alloc_chrdev_region(&dev, 0, 1, MM_DEBUG_LINK_NAME);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "error from alloc_chrdev_region %d\n", ret);
+		goto free_class;
+	}
+
+	cdev_init(&pdata->mmdebuglink_cdev, &mm_debug_link_fops);
+	ret = cdev_add(&pdata->mmdebuglink_cdev, dev, 1);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "error from cdev_add %d\n", ret);
+		goto free_region;
+	}
+
+	if (IS_ERR(device_create(mm_debug_link_class, &pdev->dev,
+				 dev, NULL, MM_DEBUG_LINK_NAME))) {
+		dev_err(&pdev->dev, "can't create device in /dev\n");
+		ret = -ENODEV;
+		goto free_cdev;
+	}
+
+	return 0;
+
+free_cdev:
+	cdev_del(&pdata->mmdebuglink_cdev);
+free_region:
+	unregister_chrdev_region(pdata->mmdebuglink_cdev.dev, 1);
+free_class:
+	class_destroy(mm_debug_link_class);
+free_kfifo:
+	kfifo_free(&pdata->read_kfifo);
+
+	return ret;
+}
+
+/*
+ * mm_debug_link_remove() - platform device API remove function
+ *
+ * Return: 0 on success, non-zero error code on error.
+ */
+static int mm_debug_link_remove(struct platform_device *pdev)
+{
+	struct mm_debug_link_pdata *pdata = platform_get_drvdata(pdev);
+	device_destroy(mm_debug_link_class, pdata->mmdebuglink_cdev.dev);
+	cdev_del(&pdata->mmdebuglink_cdev);
+	unregister_chrdev_region(pdata->mmdebuglink_cdev.dev, 1);
+	class_destroy(mm_debug_link_class);
+	kfifo_free(&pdata->read_kfifo);
+
+	return 0;
+}
+
+static const struct of_device_id mm_debug_link_of_match[] = {
+	{.compatible = "altr,mm-debug-link-1.0",},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, mm_debug_link_of_match);
+
+static struct platform_driver mm_debug_link_driver = {
+	.probe = mm_debug_link_probe,
+	.remove = mm_debug_link_remove,
+	.driver = {
+		   .name = MM_DEBUG_LINK_NAME,
+		   .owner = THIS_MODULE,
+		   .of_match_table = mm_debug_link_of_match,
+		   },
+};
+
+/*
+ * mm_debug_link_init() - module API init function
+ *
+ */
+static int __init mm_debug_link_init(void)
+{
+	return platform_driver_probe(&mm_debug_link_driver,
+		mm_debug_link_probe);
+}
+
+/*
+ * mm_debug_link_exit() - module API exit function
+ *
+ */
+static void __exit mm_debug_link_exit(void)
+{
+	platform_driver_unregister(&mm_debug_link_driver);
+}
+
+module_init(mm_debug_link_init);
+module_exit(mm_debug_link_exit);
+
+MODULE_AUTHOR("Aaron Ferrucci (Altera)");
+MODULE_DESCRIPTION("Altera MM DEBUG_LINK Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/char/sld-hub.c b/drivers/char/sld-hub.c
deleted file mode 100644
index 8ece995..0000000
--- a/drivers/char/sld-hub.c
+++ /dev/null
@@ -1,305 +0,0 @@
- /*
-  *  drivers/char/sld-hub.c
-  *
-  * SLD HUB driver
-  *
-  * Copyright (C) 2014 Altera Corporation. All rights reserved
-  *
-  * This program is free software; you can redistribute it and/or modify it
-  * under the terms and conditions of the GNU General Public License,
-  * version 2, as published by the Free Software Foundation.
-  *
-  * This program is distributed in the hope it will be useful, but WITHOUT
-  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-  * more details.
-  *
-  * You should have received a copy of the GNU General Public License along with
-  * this program.  If not, see <http://www.gnu.org/licenses/>.
-  */
-
-#include <linux/cdev.h>
-#include <linux/debugfs.h>
-#include <linux/io.h>
-#include <linux/kfifo.h>
-#include <linux/module.h>
-#include <linux/of_device.h>
-#include <linux/sld-hub.h>
-#include <linux/uaccess.h>
-
-#define SLD_HUB_NAME "sld_hub"
-
-#define ALT_SLD_HUB_DATA_WRITE        0x00
-#define ALT_SLD_HUB_DATA_READ         0x08
-#define ALT_SLD_HUB_FIFO_WRITE_COUNT  0x20
-#define ALT_SLD_HUB_FIFO_READ_COUNT   0x40
-#define ALT_SLD_HUB_ID_ROM            0x60
-#define ALT_SLD_HUB_MGMT_INTF         0x70
-
-#define ALT_SLD_HUB_FIFO_SIZE         32
-#define ALT_SLD_HUB_READ_BUF_SIZE     4096
-#define ALT_SLD_HUB_ROMID_SIZE        16
-
-#define ALT_SLD_HUB_FLAG_BUSY         0
-
-struct sld_hub_pdata {
-	struct platform_device *pdev;
-
-	unsigned int base_reg_phy;
-	void __iomem *base_reg;
-
-	unsigned long flags;
-
-	struct kfifo read_kfifo;
-	unsigned char kbuf[ALT_SLD_HUB_FIFO_SIZE];
-
-	struct cdev sld_cdev;
-};
-
-static int sld_hub_remove(struct platform_device *pdev);
-
-static struct class *sld_hub_class;
-
-static int _read_sldfifo_into_kfifo(struct sld_hub_pdata *pdata)
-{
-	int num_bytes;
-	int n;
-	char chr;
-
-	num_bytes = readb(pdata->base_reg + ALT_SLD_HUB_FIFO_READ_COUNT);
-	for (n = 0; n < num_bytes; n++) {
-		if (!kfifo_is_full(&pdata->read_kfifo)) {
-			chr = readb(pdata->base_reg + ALT_SLD_HUB_DATA_READ);
-			kfifo_in(&pdata->read_kfifo, &chr, 1);
-		} else {
-			dev_err(&pdata->pdev->dev, "Read Buffer FULL!\n");
-			break;
-		}
-	}
-
-	return n;
-}
-
-static ssize_t sld_hub_write(struct file *file, const char __user *user_buf,
-			     size_t count, loff_t *ppos)
-{
-	struct sld_hub_pdata *pdata = file->private_data;
-	int num_bytes;
-	int n;
-
-	/*
-	 * The design of the SLD HUB controller requires keeping the read
-	 * FIFO not full, so we empty it every time we write
-	 */
-	_read_sldfifo_into_kfifo(pdata);
-
-	num_bytes =
-	    ALT_SLD_HUB_FIFO_SIZE - readb(pdata->base_reg +
-					  ALT_SLD_HUB_FIFO_WRITE_COUNT);
-
-	if (num_bytes == 0) {
-		dev_err(&pdata->pdev->dev,
-			"SLD HUB write fifo full!\n");
-		return 0;
-	}
-
-	*ppos = 0;
-	num_bytes = simple_write_to_buffer(pdata->kbuf,
-				num_bytes, ppos, user_buf, count);
-
-	for (n = 0; n < num_bytes; n++)
-		writeb(pdata->kbuf[n],
-		       pdata->base_reg + ALT_SLD_HUB_DATA_WRITE);
-
-	return num_bytes;
-}
-
-static ssize_t sld_hub_read(struct file *file, char __user *user_buf,
-			    size_t count, loff_t *ppos)
-{
-	int num_bytes;
-	struct sld_hub_pdata *pdata = file->private_data;
-
-	_read_sldfifo_into_kfifo(pdata);
-
-	if (kfifo_to_user(&pdata->read_kfifo, user_buf, count, &num_bytes))
-		dev_err(&pdata->pdev->dev,
-			"Error copying fifo data to user data! %d bytes copied\n",
-			num_bytes);
-
-	return num_bytes;
-}
-
-static int sld_hub_open(struct inode *inode, struct file *file)
-{
-	struct sld_hub_pdata *pdata;
-
-	pdata = container_of(inode->i_cdev, struct sld_hub_pdata, sld_cdev);
-	if (test_and_set_bit_lock(ALT_SLD_HUB_FLAG_BUSY, &pdata->flags))
-		return -EBUSY;
-	file->private_data = pdata;
-
-	return 0;
-}
-
-static int sld_hub_release(struct inode *inode, struct file *file)
-{
-	int ret = 0;
-	struct sld_hub_pdata *pdata;
-
-	pdata = container_of(inode->i_cdev, struct sld_hub_pdata, sld_cdev);
-	file->private_data = NULL;
-	clear_bit_unlock(ALT_SLD_HUB_FLAG_BUSY, &pdata->flags);
-
-	return ret;
-}
-
-static long sld_hub_read_romid(struct file *file, unsigned long arg)
-{
-	struct sld_hub_pdata *pdata = file->private_data;
-	int i;
-
-	for (i = 0; i < ALT_SLD_HUB_ROMID_SIZE; i++)
-		pdata->kbuf[i] = readb(pdata->base_reg +
-				ALT_SLD_HUB_ID_ROM + i);
-
-	if (copy_to_user((void __user *)arg, pdata->kbuf,
-			 ALT_SLD_HUB_ROMID_SIZE))
-		return -EFAULT;
-
-	return 0;
-}
-
-static long sld_hub_ioctl(struct file *file, unsigned int cmd,
-			  unsigned long arg)
-{
-	switch (cmd) {
-	case SLDHUB_IO_ROMID:
-		return sld_hub_read_romid(file, arg);
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static const struct file_operations sld_hub_fops = {
-	.write = sld_hub_write,
-	.read = sld_hub_read,
-	.open = sld_hub_open,
-	.release = sld_hub_release,
-	.unlocked_ioctl = sld_hub_ioctl,
-	.llseek = no_llseek,
-};
-
-static int sld_hub_probe(struct platform_device *pdev)
-{
-	struct resource *areg;
-	struct sld_hub_pdata *pdata;
-	int ret;
-	dev_t dev;
-
-	pdata = devm_kzalloc(&pdev->dev, sizeof(struct sld_hub_pdata),
-			     GFP_KERNEL);
-	if (!pdata)
-		return -ENOMEM;
-
-	areg = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	pdata->base_reg = devm_request_and_ioremap(&pdev->dev, areg);
-	if (!pdata->base_reg)
-		return -EADDRNOTAVAIL;
-	pdata->base_reg_phy = areg->start;
-
-	pdata->pdev = pdev;
-	platform_set_drvdata(pdev, pdata);
-
-	if (kfifo_alloc(&pdata->read_kfifo,
-			ALT_SLD_HUB_READ_BUF_SIZE, GFP_KERNEL))
-		return -ENOMEM;
-
-	sld_hub_class = class_create(THIS_MODULE, SLD_HUB_NAME);
-	if (IS_ERR(sld_hub_class)) {
-		ret = PTR_ERR(sld_hub_class);
-		goto free_kfifo;
-	}
-
-	ret = alloc_chrdev_region(&dev, 0, 1, SLD_HUB_NAME);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "error from alloc_chrdev_region %d\n", ret);
-		goto free_class;
-	}
-
-	cdev_init(&pdata->sld_cdev, &sld_hub_fops);
-	ret = cdev_add(&pdata->sld_cdev, dev, 1);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "error from cdev_add %d\n", ret);
-		goto free_region;
-	}
-
-	if (IS_ERR(device_create(sld_hub_class, &pdev->dev,
-				 dev, NULL, SLD_HUB_NAME))) {
-		dev_err(&pdev->dev, "can't create device in /dev\n");
-		ret = -ENODEV;
-		goto free_cdev;
-	}
-
-	return 0;
-
-free_cdev:
-	cdev_del(&pdata->sld_cdev);
-free_region:
-	unregister_chrdev_region(pdata->sld_cdev.dev, 1);
-free_class:
-	class_destroy(sld_hub_class);
-free_kfifo:
-	kfifo_free(&pdata->read_kfifo);
-
-	return ret;
-}
-
-static int sld_hub_remove(struct platform_device *pdev)
-{
-	struct sld_hub_pdata *pdata = platform_get_drvdata(pdev);
-
-	device_destroy(sld_hub_class, pdata->sld_cdev.dev);
-	cdev_del(&pdata->sld_cdev);
-	unregister_chrdev_region(pdata->sld_cdev.dev, 1);
-	class_destroy(sld_hub_class);
-	kfifo_free(&pdata->read_kfifo);
-
-	return 0;
-}
-
-static const struct of_device_id sld_hub_of_match[] = {
-	{.compatible = "altr,sld-hub",},
-	{},
-};
-
-MODULE_DEVICE_TABLE(of, sld_hub_of_match);
-
-static struct platform_driver sld_hub_driver = {
-	.probe = sld_hub_probe,
-	.remove = sld_hub_remove,
-	.driver = {
-		   .name = SLD_HUB_NAME,
-		   .owner = THIS_MODULE,
-		   .of_match_table = sld_hub_of_match,
-		   },
-};
-
-static int __init sld_hub_init(void)
-{
-	return platform_driver_probe(&sld_hub_driver, sld_hub_probe);
-}
-
-static void __exit sld_hub_exit(void)
-{
-	platform_driver_unregister(&sld_hub_driver);
-}
-
-module_init(sld_hub_init);
-module_exit(sld_hub_exit);
-
-MODULE_AUTHOR("Graham Moore (Altera)");
-MODULE_DESCRIPTION("Altera SLD HUB Driver");
-MODULE_LICENSE("GPL v2");
diff --git a/include/linux/mm-debug-link.h b/include/linux/mm-debug-link.h
new file mode 100644
index 0000000..004b52d
--- /dev/null
+++ b/include/linux/mm-debug-link.h
@@ -0,0 +1,39 @@
+/*
+ *  include/linux/mm-debug-link.h
+ *
+ * MM Debug Link driver header file
+ *
+ * Adapted from sld-hub driver written by Graham Moore (grmoore@altera.com)
+ *
+ * Copyright (C) 2014 Altera Corporation. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __MM_DEBUG_LINK_H__
+
+#include <linux/ioctl.h>
+
+/*
+ * The size in bytes of the connection identification ROM
+ * within altera_mm_debug_link. (A constant feature of the hardware.)
+ */
+#define MM_DEBUG_LINK_ID_SIZE		((size_t)16)
+#define MM_DEBUG_LINK_CODE		0xA1
+#define MM_DEBUG_LINK_IOCTL_READ_ID	_IOR((MM_DEBUG_LINK_CODE), 1, \
+					unsigned char[MM_DEBUG_LINK_ID_SIZE])
+#define MM_DEBUG_LINK_IOCTL_WRITE_MIXER	_IOW((MM_DEBUG_LINK_CODE), 2, int)
+#define MM_DEBUG_LINK_IOCTL_ENABLE	_IOW((MM_DEBUG_LINK_CODE), 3, int)
+#define MM_DEBUG_LINK_IOCTL_DEBUG_RESET	_IOW((MM_DEBUG_LINK_CODE), 4, int)
+
+#endif /* #ifndef __MM_DEBUG_LINK_H__ */
-- 
1.8.2.1